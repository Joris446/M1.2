<!DOCTYPE html>
<html>
<head>
  <title>Wandelroute Waalre</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
  <style>
    html, body { height: 100%; margin: 0; padding: 0; }
    body { font-family: 'Segoe UI', Arial, sans-serif; background: #fff; }
    #map { height: 100vh; display: none; }
    .center-screen {
      position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
      background: #fff; display: flex; flex-direction: column;
      align-items: center; justify-content: center; z-index: 10;
    }
    .welcome-title { font-size: 3em; font-weight: bold; margin-bottom: 0.5em; }
    .welcome-question { font-size: 1.5em; margin-bottom: 2em; }
    .start-btn, .route-btn {
      padding: 0.8em 2em; font-size: 1.2em; border: none; border-radius: 8px;
      background: #0078d7; color: #fff; cursor: pointer; margin: 0.5em 0;
      transition: background 0.2s;
    }
    .start-btn:hover, .route-btn:hover { background: #005fa3; }
    .route-options { display: flex; flex-direction: column; align-items: center; }
    .route-option {
      background: #f5f5f5; border-radius: 10px; padding: 1.2em 2em;
      margin: 0.7em 0; width: 320px; text-align: center; font-size: 1.2em;
      box-shadow: 0 2px 8px rgba(0,0,0,0.04);
    }
    @media (max-width: 600px) {
      .route-option { width: 90vw; }
      .welcome-title { font-size: 2em; }
      .welcome-question { font-size: 1.1em; }
    }
    .user-dot {
      width: 12px; height: 12px; background-color: blue;
      border-radius: 50%; border: 2px solid white;
    }
  </style>
</head>
<body>
  <!-- Welcome Screen -->
  <div id="welcomeScreen" class="center-screen">
    <div class="welcome-title">Welkom</div>
    <div class="welcome-question">Klaar om een rondje te gaan lopen?</div>
    <button class="start-btn" onclick="showRouteScreen()">Start</button>
  </div>

  <!-- Route Selection Screen -->
  <div id="routeScreen" class="center-screen" style="display:none;">
    <div class="route-options">
      <div class="route-option" onclick="selectRoute('kort')">
        <b>Frisse neus halen</b> <br>(400 m)
      </div>
      <div class="route-option" onclick="selectRoute('middel')">
        <b>De benen strekken</b> <br>(800 m)
      </div>
      <div class="route-option" onclick="selectRoute('lang')">
        <b>Even eruit</b> <br>(2 km)
      </div>
    </div>
  </div>

  <!-- Map -->
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf/turf.min.js"></script>
  <script>
    // --- UI State ---
    function showRouteScreen() {
      document.getElementById('welcomeScreen').style.display = 'none';
      document.getElementById('routeScreen').style.display = 'flex';
    }
    function selectRoute(type) {
      document.getElementById('routeScreen').style.display = 'none';
      document.getElementById('map').style.display = 'block';
      startSimulation(type);
    }

    // --- Map and Data ---
    let map, currentMarker = null, userPosition = [51.3865, 5.4439];
    let routeLine = null, routeCoords = [];
    let geojsonData = [];
    const announcedTypes = new Set();
    let currentRouteIndex = 0;
    let lastObjectAnnounceTime = 0;
    let lastDirectionAnnounceTime = 0;
    let blockDirectionsUntil = 0;

    // Weather state
    let weatherData = null;
    let lastSpokenTime = 0;
    let lastWeatherAnnounceTime = 0;
    let weatherSentenceSpoken = false; // Add this at the top with other state variables

    // ðŸ—£ï¸ Vooraf ingestelde zinnen per objecttype
    const objectZinnen = {
      "boom": "Je loopt langs een mooie boom.",
      "bank": "Hier staat een bankje. Wil je even pauzeren?",
      "kunstobject": "Er staat een kunstobject aan je rechterzijde.",
      "speeltuin": "Je bent bij een speeltuin. Kinderen spelen hier vaak vrolijk.",
      "sportterrein": "Links van je ligt een sportterrein.",
      "afvalbak": "Hier staat een afvalbak. Handig als je iets kwijt moet.",
      "container": "Er staat een container in de buurt.",
      "fietsenrek": "Je nadert een fietsenrek. Een plek om je fiets te parkeren.",
      "klinkers": "Je loopt nu over gebakken klinkers.",
      "haag": "Langs het pad zie je een nette haag.",
      "restaurant": "Ah, daar is een restaurant. Zo gezellig dat er eetplekjes in de buurt zitten."
    };

    function speak(text) {
      lastSpokenTime = Date.now();
      const utterance = new SpeechSynthesisUtterance(text);
      speechSynthesis.speak(utterance);
      // speakWithElevenLabs(text); // gebruik nu ElevenLabs i.p.v. SpeechSynthesis
      if (map) {
        const popup = L.popup()
          .setLatLng([userPosition[0], userPosition[1]])
          .setContent(text)
          .openOn(map);
        setTimeout(() => map.closePopup(popup), 4000);
      }
    }

    async function loadObjects() {
      const files = [
        'objects/boom.geojson',
        'objects/bank.geojson',
        'objects/kunstobject.geojson',
        'objects/speeltuin.geojson',
        'objects/sportterrein.geojson',
        'objects/afvalbak.geojson',
        'objects/fietsenrek.geojson',
        'objects/haag.geojson',
        'objects/klinkers.geojson',
        'objects/restaurant.geojson',
        'objects/kerk.geojson' // <-- Add this line for churches
      ];
      const allObjects = [];
      for (const file of files) {
        try {
          const res = await fetch(file);
          const geo = await res.json();
          // For restaurant.geojson, set type to "restaurant" if not present
          if (file.includes('restaurant.geojson')) {
            geo.features.forEach(f => {
              if (!f.properties.type) f.properties.type = "restaurant";
            });
          }
          // For kerk.geojson, set type to "kerk" if not present
          if (file.includes('kerk.geojson')) {
            geo.features.forEach(f => {
              if (!f.properties.type) f.properties.type = "kerk";
            });
          }
          allObjects.push(...geo.features);
        } catch (err) {
          // Ignore missing files
        }
      }
      return allObjects;
    }

    async function loadRoute(type) {
      let file = '';
      if (type === 'kort') file = 'Routes/route_kort.geojson';
      if (type === 'middel') file = 'Routes/route_middel.geojson';
      if (type === 'lang') file = 'Routes/route_lang.geojson';
      const res = await fetch(file);
      const geo = await res.json();
      // Assume first feature is the route
      return geo.features[0].geometry.coordinates;
    }

    async function fetchWeather() {
      // Replace YOUR_API_KEY with your OpenWeatherMap API key
      const apiKey = '128e6da6a66e01537fb6ca168cf0f677';
      const url = `https://api.openweathermap.org/data/2.5/weather?lat=51.3865&lon=5.4439&units=metric&appid=${apiKey}&lang=nl`;
      try {
        const res = await fetch(url);
        if (!res.ok) return null;
        return await res.json();
      } catch {
        return null;
      }
    }

    function getWeatherSentence(weather) {
      if (!weather) return null;
      const temp = weather.main.temp;
      const main = weather.weather[0].main.toLowerCase();
      const desc = weather.weather[0].description.toLowerCase();
      const isRaining = main.includes("rain") || desc.includes("regen");
      const isSunny = main.includes("clear") || desc.includes("zon");
      const isCloudy = main.includes("cloud") || desc.includes("bewolkt") || desc.includes("wolken");

      if (isRaining) {
        return "Wat goed dat je met dit weer een wandelingetje gaat maken zeg! Zo goed om even de benen te strekken.";
      }
      if (isSunny && temp > 22) {
        return "Pfoee, wat een lekker warm weertje vandaag he?";
      }
      if (isSunny && temp >= 10 && temp <= 22) {
        return "Wat een heerlijk zonnetje schijnt er vandaag he?";
      }
      if (temp < 10 && !isRaining) {
        if (isCloudy) {
          return "Lekker fris buiten, maar zoâ€™n wandeling doet altijd goed!";
        }
        return "Fris weertje vandaag hÃ¨? Goed om toch even naar buiten te gaan!";
      }
      if (isCloudy && temp > 10) {
        return "Ook zonder zon is het fijn om even een frisse neus te halen!";
      }
      return null;
    }

    async function speakWeatherIfQuiet() {
      const now = Date.now();
      if (!weatherData) return;
      // Only if nothing spoken for 10s, and not just after weather, and only once
      if (!weatherSentenceSpoken && now - lastSpokenTime > 10000 && now - lastWeatherAnnounceTime > 10000) {
        const zin = getWeatherSentence(weatherData);
        if (zin) {
          speak(zin);
          lastWeatherAnnounceTime = Date.now();
          blockDirectionsUntil = Date.now() + 3000; // Block directions for 3s
          lastObjectAnnounceTime = Date.now(); // Block objects for 10s
          weatherSentenceSpoken = true; // Prevent further weather announcements
        }
      }
    }

    async function speakWithElevenLabs(text) {
      // ...existing code...
    }

    async function fetchRealWorldRoute(waypoints) {
      // If there are less than 3 points, just return as is
      if (waypoints.length < 3) return waypoints;

      // Keep first and last point as-is
      const first = waypoints[0];
      const last = waypoints[waypoints.length - 1];
      const middle = waypoints.slice(1, -1);

      // Snap only the middle points to the road
      const apiKey = '5b3ce3597851110001cf62487fcb39e0f04c4854b85088cd255aee42';
      const url = 'https://api.openrouteservice.org/v2/directions/foot-walking/geojson';
      const body = { coordinates: [first, ...middle, last] };
      const res = await fetch(url, {
        method: 'POST',
        headers: {
          'Authorization': apiKey,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(body)
      });
      const data = await res.json();

      // Replace the first and last snapped points with the original ones
      let snapped = data.features[0].geometry.coordinates;
      if (snapped.length >= 2) {
        snapped[0] = first;
        snapped[snapped.length - 1] = last;
      }
      return snapped;
    }

    function updateUserLocation(lat, lon) {
      userPosition = [lat, lon];
      if (currentMarker) map.removeLayer(currentMarker);
      const icon = L.divIcon({ className: 'user-dot' });
      currentMarker = L.marker([lat, lon], { icon }).addTo(map);
    }

    function checkNearbyObjects(userCoords, features) {
      const now = Date.now();
      // Only allow object announcement if 10s since last object and 5s since last direction
      if (now - lastObjectAnnounceTime < 10000) return;
      if (now - lastDirectionAnnounceTime < 5000) return;

      for (const feature of features) {
        if (!feature.geometry || !Array.isArray(feature.geometry.coordinates)) continue;
        let objectCoords;
        if (feature.geometry.type === 'Point') {
          objectCoords = feature.geometry.coordinates;
        } else if (feature.geometry.type === 'Polygon') {
          const centroid = turf.centroid(feature.geometry).geometry.coordinates;
          objectCoords = centroid;
        } else continue;
        if (typeof objectCoords[0] !== 'number' || typeof objectCoords[1] !== 'number') continue;

        // Bepaal het type en de juiste afstandsgrens
        let type = feature.properties?.type || feature.properties?.["plus-type"] || "onbekend";
        if (typeof type !== "string") type = "onbekend";
        type = type.toLowerCase();
        const distanceThreshold = (type === "kerk") ? 60 : 15;

        const distance = turf.distance(
          turf.point([userCoords[1], userCoords[0]]),
          turf.point([objectCoords[0], objectCoords[1]]),
          { units: 'meters' }
        );
        if (distance < distanceThreshold && !feature.properties.announced) {
          feature.properties.announced = true;
          if (announcedTypes.has(type)) continue;
          announcedTypes.add(type);

          // Special handling for kerk: include the name if available
          if (type === "kerk") {
            const kerkNaam = feature.properties.name ? feature.properties.name : "de kerk";
            speak(`Hier zie je ${kerkNaam}, een bijzonder gebouw in het dorp.`);
          } else {
            const zin = objectZinnen[type] || "Je komt langs een onbekend object.";
            speak(zin);
          }
          lastObjectAnnounceTime = Date.now();
          blockDirectionsUntil = Date.now() + 3000;
          return;
        }
      }
    }

    function checkHardcodedTurns(userCoords) {
      const now = Date.now();
      if (now < blockDirectionsUntil) return;

      const normalTurns = activeTurnPoints.slice(0, -2);
      const lastRechts = activeTurnPoints[activeTurnPoints.length - 2];
      const weerTerug = activeTurnPoints[activeTurnPoints.length - 1];

      function getTurnSentence(dir) {
        if (dir === "rechts") return "Laten we hier rechtsaf slaan.";
        if (dir === "links") return "Hier gaan we naar links.";
        if (dir === "rechtdoor") return "Hier blijven we rechtdoor gaan.";
        return `Hier moet je naar ${dir}`;
      }

      // Announce normal turns first
      for (const turn of normalTurns) {
        if (turn.announced) continue;
        const dist = turf.distance(
          turf.point([userCoords[1], userCoords[0]]),
          turf.point([turn.lng, turn.lat]),
          { units: 'meters' }
        );
        if (dist < 9) {
          speak(getTurnSentence(turn.dir));
          turn.announced = true;
          lastDirectionAnnounceTime = Date.now();
          return;
        }
      }

      // Only announce the last "rechts" if all previous are announced
      if (normalTurns.every(t => t.announced) && lastRechts && !lastRechts.announced) {
        const dist = turf.distance(
          turf.point([userCoords[1], userCoords[0]]),
          turf.point([lastRechts.lng, lastRechts.lat]),
          { units: 'meters' }
        );
        if (dist < 8) {
          speak(getTurnSentence(lastRechts.dir));
          lastRechts.announced = true;
          lastDirectionAnnounceTime = Date.now();
          return;
        }
      }

      // Only announce "Weer terug" if all previous are announced
      if (
        normalTurns.every(t => t.announced) &&
        lastRechts && lastRechts.announced &&
        weerTerug && !weerTerug.announced
      ) {
        const dist = turf.distance(
          turf.point([userCoords[1], userCoords[0]]),
          turf.point([weerTerug.lng, weerTerug.lat]),
          { units: 'meters' }
        );
        if (dist < 8) {
          speak("En daar zijn we weer terug bij het klooster. Voor je zie je de voordeur. Wat fijn om zo samen op pad te zijn geweest.");
          weerTerug.announced = true;
          lastDirectionAnnounceTime = Date.now();
          showEndScreen();
          return;
        }
      }
    }

    // --- Route Guidance ---
    function getNextRouteIndex(pos, coords, currentIdx) {
      // Find the closest next point on the route
      let minDist = Infinity, idx = currentIdx;
      for (let i = currentIdx; i < coords.length; i++) {
        const dist = turf.distance(
          turf.point([pos[1], pos[0]]),
          turf.point([coords[i][0], coords[i][1]]),
          { units: 'meters' }
        );
        if (dist < minDist) {
          minDist = dist;
          idx = i;
        }
      }
      return idx;
    }

    let lastTurnIdx = -1;
    function checkRouteGuidance(pos, coords) {
      // Find closest point on route
      const idx = getNextRouteIndex(pos, coords, currentRouteIndex);
      if (idx > currentRouteIndex) currentRouteIndex = idx;
      // Check if a turn is coming up
      if (idx > 0 && idx < coords.length - 1 && idx !== lastTurnIdx) {
        const prev = coords[idx - 1], curr = coords[idx], next = coords[idx + 1];
        const turn = getTurnInstruction(prev, curr, next);
        if (turn) {
          speak(`Hier moet je naar ${turn}`);
          lastTurnIdx = idx;
        }
      }
    }

    // --- Hardcoded turn points for each route type ---
    // Fill in the coordinates and directions for your routes!
    const turnPointsByRoute = {
      kort: [
        // Example: { lat: 51.3867, lng: 5.4441, dir: "links" }
        // Add your real turn points here
        { lat: 51.387481, lng: 5.443403, dir: "rechts" },
        { lat: 51.387714, lng: 5.443246, dir: "links" },
        { lat: 51.387627, lng: 5.441539, dir: "links" },
        { lat: 51.387028, lng: 5.441920, dir: "rechtdoor" },
        { lat: 51.386585, lng: 5.443084, dir: "links" },
        { lat: 51.386609, lng: 5.443492, dir: "links" },
        { lat: 51.387121, lng: 5.443417, dir: "rechtdoor" },
        { lat: 51.387481, lng: 5.443403, dir: "rechts" },
        { lat: 51.387536, lng: 5.443614, dir: "Weer terug" },

      ],
      middel: [
        { lat: 51.3870, lng: 5.4450, dir: "links" },
        { lat: 51.3872, lng: 5.4453, dir: "rechts" }
      ],
      lang: [
        { lat: 51.3880, lng: 5.4460, dir: "links" },
        { lat: 51.3882, lng: 5.4463, dir: "rechts" }
      ]
    };

    let activeTurnPoints = [];

    function setActiveTurnPoints(routeType) {
      activeTurnPoints = (turnPointsByRoute[routeType] || []).map(tp => ({
        ...tp,
        announced: false
      }));
    }

    // --- Main Simulation ---
    async function startSimulation(routeType) {
      // Fetch weather at the start of the walk
      weatherData = await fetchWeather();

      // Init map
      map = L.map('map', { keyboard: false }).setView([51.3865, 5.4439], 17);
      L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

      // Load route and objects
      const waypoints = await loadRoute(routeType);
      routeCoords = await fetchRealWorldRoute(waypoints);

      geojsonData = await loadObjects();

      // Draw route
      if (routeLine) map.removeLayer(routeLine);
      routeLine = L.polyline(routeCoords.map(c => [c[1], c[0]]), { color: 'red', weight: 5 }).addTo(map);
      map.fitBounds(routeLine.getBounds());

      // Place user at start
      userPosition = [routeCoords[0][1], routeCoords[0][0]];
      updateUserLocation(userPosition[0], userPosition[1]);
      currentRouteIndex = 0;
      lastTurnIdx = -1;
      announcedTypes.clear();
      geojsonData.forEach(f => { if (f.properties) f.properties.announced = false; });

      setActiveTurnPoints(routeType);

      // Keyboard navigation
      document.addEventListener('keydown', onKeyMove);

      // Initial check
      lastSpokenTime = Date.now();
      lastWeatherAnnounceTime = 0;
      checkNearbyObjects(userPosition, geojsonData);

      // Start weather check interval
      if (window.weatherInterval) clearInterval(window.weatherInterval);
      window.weatherInterval = setInterval(speakWeatherIfQuiet, 1000);
    }

    function onKeyMove(e) {
      const moveStep = 0.00002;
      switch (e.key) {
        case 'ArrowUp': userPosition[0] += moveStep; break;
        case 'ArrowDown': userPosition[0] -= moveStep; break;
        case 'ArrowLeft': userPosition[1] -= moveStep; break;
        case 'ArrowRight': userPosition[1] += moveStep; break;
        default: return;
      }
      updateUserLocation(userPosition[0], userPosition[1]);
      map.panTo([userPosition[0], userPosition[1]]);
      checkNearbyObjects(userPosition, geojsonData);
      checkHardcodedTurns(userPosition);
      // lastSpokenTime = Date.now(); // <-- REMOVE or COMMENT OUT this line
    }

    // End screen HTML
    const endScreenHtml = `
      <div id="endScreen" class="center-screen" style="display:none;">
        <div style="font-size:2em; margin-bottom:1em;">Dankjewel dat je met mij wilde lopen.<br>Wat was het weer een fijne wandeling!</div>
        <button class="start-btn" onclick="restartWalk()">Ik wil nog een wandeling maken</button>
      </div>
    `;
    document.body.insertAdjacentHTML('beforeend', endScreenHtml);

    function showEndScreen() {
      document.getElementById('map').style.display = 'none';
      document.getElementById('endScreen').style.display = 'flex';
      if (window.weatherInterval) clearInterval(window.weatherInterval);
    }

    function restartWalk() {
      document.getElementById('endScreen').style.display = 'none';
      document.getElementById('routeScreen').style.display = 'flex';

      lastObjectAnnounceTime = 0;
      lastDirectionAnnounceTime = 0;
      blockDirectionsUntil = 0;
      lastTurnIdx = -1;
      currentRouteIndex = 0;
      lastSpokenTime = Date.now();
      lastWeatherAnnounceTime = 0;
      weatherSentenceSpoken = false; // Reset here

      announcedTypes.clear();
      if (geojsonData && geojsonData.length > 0) {
        geojsonData.forEach(f => { if (f.properties) f.properties.announced = false; });
      }
      if (typeof activeTurnPoints !== "undefined" && activeTurnPoints.length > 0) {
        activeTurnPoints.forEach(tp => tp.announced = false);
      }

      if (currentMarker) {
        map.removeLayer(currentMarker);
        currentMarker = null;
      }
      if (routeLine) {
        map.removeLayer(routeLine);
        routeLine = null;
      }

      userPosition = [51.3865, 5.4439];
      document.removeEventListener('keydown', onKeyMove);

      if (map) {
        map.remove();
        map = null;
      }
    }
  </script>
</body>
</html>



