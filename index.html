<!DOCTYPE html>
<html>
<head>
  <title>Wandelroute Waalre</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
  <style>
    @font-face {
      font-family: 'Arial';
      src: local('Arial'), local('BodoniMT'), url('https://fonts.cdnfonts.com/s/17309/BodoniMT.woff') format('woff');
      font-weight: normal;
      font-style: normal;
    }
    :root {
      --background: #fefef2;
      --primary: #014b9b;
      --highlight: #e1a83e;
      --text: #0f0f0f;
      --card-bg: #fff;
      --card-border: #e1a83e;
      --shadow: 0 2px 8px rgba(1, 75, 155, 0.04);
    }
    html, body { height: 100%; margin: 0; padding: 0; }
    body {
      font-family: 'Arial', serif;
      background: var(--background);
      color: var(--text);
      min-height: 100vh;
    }
    #map { height: 100vh; display: none; }
    .center-screen {
      position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
      background: var(--background); display: flex; flex-direction: column;
      align-items: center; justify-content: center; z-index: 10;
    }
    .welcome-title {
      font-size: 3em; font-weight: bold; margin-bottom: 0.5em;
      color: var(--primary);
      letter-spacing: 1px;
      font-family: 'Segoe UI', Arial, sans-serif; /* Not Arial for Hey daar! */
    }
    .welcome-question {
      font-size: 1.5em; margin-bottom: 2em;
      color: var(--text);
      opacity: 0.85;
    }
    .start-btn, .route-btn {
      padding: 0.8em 2em; font-size: 1.2em; border: none; border-radius: 8px;
      background: var(--primary); color: #fff; cursor: pointer; margin: 0.5em 0;
      transition: background 0.2s, box-shadow 0.2s, color 0.2s;
      box-shadow: var(--shadow);
      font-weight: 600;
      letter-spacing: 0.5px;
      text-transform: lowercase;
      font-family: 'Arial', serif;
    }
    .start-btn:hover, .route-btn:hover {
      background: var(--highlight);
      color: #fff; /* Keep text white on hover */
    }
    .route-options {
      display: flex; flex-direction: column; align-items: center;
    }
    .route-option {
      background: var(--card-bg);
      border-radius: 10px;
      padding: 1.2em 2em;
      margin: 0.7em 0;
      width: 320px;
      text-align: center;
      font-size: 1.2em;
      box-shadow: var(--shadow);
      border: none; /* No border by default */
      color: var(--text); /* Dark grey text */
      font-weight: 500;
      transition: border 0.2s, background 0.2s;
      cursor: pointer;
      font-family: 'Arial', serif;
    }
    .route-option:hover {
      border: 2px solid var(--highlight); /* yellow border on hover */
      background: #f8f8f8;
      color: var(--text); /* Keep text dark grey on hover */
    }
    @media (max-width: 600px) {
      .route-option { width: 90vw; }
      .welcome-title { font-size: 2em; }
      .welcome-question { font-size: 1.1em; }
    }
    .user-dot {
      width: 16px; height: 16px;
      background-color: var(--primary);
      border-radius: 50%;
      border: 3px solid #fff;
      /* No yellow shadow */
      box-shadow: none;
    }
    .leaflet-popup-content-wrapper {
      border-radius: 10px;
      border: 2px solid var(--highlight);
      background: #fffbe7;
      color: var(--text);
      font-size: 1.1em;
      font-weight: 500;
      font-family: 'Arial', serif;
    }
    .leaflet-popup-tip {
      background: var(--highlight);
    }
    #endScreen .start-btn {
      margin-top: 2em;
    }
    #endScreen .start-btn:hover {
      color: #fff; /* Keep text white on hover */
    }
    #endScreen {
      font-family: 'Arial', serif;
    }
  </style>
</head>
<body>
  <!-- Welcome Screen -->
  <div id="welcomeScreen" class="center-screen">
    <div class="welcome-title">Hey daar!</div>
    <div class="welcome-question">Klaar om een rondje te gaan lopen?</div>
    <button class="start-btn" onclick="showRouteScreen()">start</button>
  </div>

  <!-- Route Selection Screen -->
  <div id="routeScreen" class="center-screen" style="display:none;">
    <div class="welcome-title" style="margin-bottom:0.4em;">Kies een route:</div>
    <div class="route-options">
      <div class="route-option" onclick="selectRoute('kort')">
        <b>Frisse neus halen</b> <br>(400 m)
      </div>
      <div class="route-option" onclick="selectRoute('middel')">
        <b>De benen strekken</b> <br>(800 m)
      </div>
      <div class="route-option" onclick="selectRoute('lang')">
        <b>Even eruit</b> <br>(1500 m)
      </div>
    </div>
  </div>

  <!-- Map -->
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf/turf.min.js"></script>
  <script>
    // --- UI State ---
    function showRouteScreen() {
      document.getElementById('welcomeScreen').style.display = 'none';
      document.getElementById('routeScreen').style.display = 'flex';
    }
    let openingMessageTime = 0; // Track when the opening message was spoken
    function selectRoute(type) {
      document.getElementById('routeScreen').style.display = 'none';
      document.getElementById('map').style.display = 'block';

      // Spreek de openingszin direct uit na het kiezen van de route (géén vertraging)
      speak("Hallo, ik ben Gerard. Vandaag loop ik gezellig met je mee. Ik laat je weten waneer we een afslag moeten nemen om weer terug bij het Klooster te komen. Heb je zin om een stukje te wandelen?");
      openingMessageTime = Date.now();
      blockDirectionsUntil = openingMessageTime + 10000; // Block directions for 10s after opening
      lastObjectAnnounceTime = Date.now();

      startSimulation(type);
    }

    // --- Map and Data ---
    let map, currentMarker = null, userPosition = [51.3865, 5.4439];
    let routeLine = null, routeCoords = [];
    let geojsonData = [];
    const announcedTypes = new Set();
    let currentRouteIndex = 0;
    let lastObjectAnnounceTime = 0;
    let lastDirectionAnnounceTime = 0;
    let blockDirectionsUntil = 0;

    // Weather state
    let weatherData = null;
    let lastSpokenTime = 0;
    let lastWeatherAnnounceTime = 0;
    let weatherSentenceSpoken = false; // Add this at the top with other state variables

    // Off-route warning state
    let offRouteWarned = false;

    // Previous user position
    let previousUserPosition = null;

    // Direction and encouragement state
    let directionCount = 0; // telt het aantal gegeven navigatie-aanwijzingen
    let encouragementGiven = false;

    // 🗣️ Vooraf ingestelde zinnen per objecttype
    const objectZinnen = {
            "boom": "Wat een mooie boom daar. Die lijkt al heel oud",
      "bank": "Kijk, daar is een bankje. Als je wilt, kunnen we even pauzeren.",
      "kunstobject": "Wat een bijzonder kunstobject staat daar. Je kan daar lang naar kijken.",
      "speeltuin": "Je bent bij een speeltuin. Kinderen spelen hier vaak vrolijk.",
      "sportterrein": "Bewegen is gezond. Fijn dat mensen hier kunnen sporten.",
      "afvalbak": "Goed om te zien dat mensen hun afval netjes weggooien. Dat houdt het hier zo prettig.",
      "container": "Goed om te zien dat mensen hun afval netjes weggooien. Dat houdt het hier zo prettig.",
      "fietsenrek": "Goed geregeld, die fietsenrekken. Zo blijft alles overzichtelijk.",
      "klinkers": "Oude klinker stenen maken de straat gezellig, vind je niet?",
      "haag": "Wat een mooie groene haag. Die is goed bijgehouden.",
      "restaurant": "Ah, daar is een restaurant. Zo gezellig dat er eetplekjes in de buurt zitten."
    };

    // --- Timing constants (in ms) ---
const DIRECTION_MIN_INTERVAL = 5000;      // 6 seconds after any message
const AFTER_DIRECTION_BLOCK = 13000;      // 30 seconds block after direction for other messages
const OBJECT_WEATHER_REASSURE_MIN = 60000; // 90 seconds between object/weather/reassure messages

// --- Track last times ---
let lastAnySpokenTime = 0;         // Last time anything was spoken
let lastDirectionSpokenTime = 0;   // Last time a direction was spoken
let lastObjectWeatherReassureTime = 0; // Last time object/weather/reassure was spoken

// --- Speak wrapper to update times ---
function speak(text, type = "other") {
  lastAnySpokenTime = Date.now();
  if (type === "direction") lastDirectionSpokenTime = Date.now();
  if (type === "object" || type === "weather" || type === "reassure") lastObjectWeatherReassureTime = Date.now();

  const utterance = new SpeechSynthesisUtterance(text);
  speechSynthesis.speak(utterance);
  //speakWithElevenLabs(text); // gebruik nu ElevenLabs i.p.v. SpeechSynthesis
  if (map) {
    const popup = L.popup()
      .setLatLng([userPosition[0], userPosition[1]])
      .setContent(text)
      .openOn(map);
    setTimeout(() => map.closePopup(popup), 4000);
  }
}

// --- Adjusted checkNearbyObjects ---
function checkNearbyObjects(userCoords, features) {
  const now = Date.now();
  // --- NIEUW: Wacht tot er minstens 2 directies zijn gegeven ---
  if (directionCount < 2) return;
  // Alleen toestaan als:
  // - 30s na laatste direction
  // - 90s na laatste object/weather/reassure
  if (now - lastDirectionSpokenTime < AFTER_DIRECTION_BLOCK) return;
  if (now - lastObjectWeatherReassureTime < OBJECT_WEATHER_REASSURE_MIN) return;

  for (const feature of features) {
    if (!feature.geometry || !Array.isArray(feature.geometry.coordinates)) continue;
    let objectCoords;
    if (feature.geometry.type === 'Point') {
      objectCoords = feature.geometry.coordinates;
    } else if (feature.geometry.type === 'Polygon') {
      const centroid = turf.centroid(feature.geometry).geometry.coordinates;
      objectCoords = centroid;
    } else continue;
    if (typeof objectCoords[0] !== 'number' || typeof objectCoords[1] !== 'number') continue;

    // Bepaal het type en de juiste afstandsgrens
    let type = feature.properties?.type || feature.properties?.["plus-type"] || "onbekend";
    if (typeof type !== "string") type = "onbekend";
    type = type.toLowerCase();
    const distanceThreshold = (type === "kerk") ? 45 : 15;

    const distance = turf.distance(
      turf.point([userCoords[1], userCoords[0]]),
      turf.point([objectCoords[0], objectCoords[1]]),
      { units: 'meters' }
    );
    if (distance < distanceThreshold && !feature.properties.announced) {
      feature.properties.announced = true;
      if (announcedTypes.has(type)) continue;
      announcedTypes.add(type);

      // Special handling for kerk: include the name if available
      if (type === "kerk") {
        const kerkNaam = feature.properties.name ? feature.properties.name : "de kerk";
        speak(`Hier zie je ${kerkNaam}, een bijzonder gebouw in het dorp.`, "object");
      } else {
        const zin = objectZinnen[type] || "Je komt langs een onbekend object.";
        speak(zin, "object");
      }
      lastObjectAnnounceTime = Date.now();
      blockDirectionsUntil = Date.now() + 3000;
      return;
    }
  }
}

// --- Adjusted speakWeatherIfQuiet ---
async function speakWeatherIfQuiet() {
  const now = Date.now();
  if (!weatherData) return;
  // Block weather message for 90s after opening message
  if (openingMessageTime && now - openingMessageTime < 90000) return;
  // Only if 30s after last direction, and 90s after last object/weather/reassure, and only once
  if (now - lastDirectionSpokenTime < AFTER_DIRECTION_BLOCK) return;
  if (now - lastObjectWeatherReassureTime < OBJECT_WEATHER_REASSURE_MIN) return;
  if (!weatherSentenceSpoken && now - lastSpokenTime > 10000 && now - lastWeatherAnnounceTime > 10000) {
    const zin = getWeatherSentence(weatherData);
    if (zin) {
      speak(zin, "weather");
      lastWeatherAnnounceTime = Date.now();
      blockDirectionsUntil = Date.now() + 3000; // Block directions for 3s
      lastObjectAnnounceTime = Date.now(); // Block objects for 10s
      weatherSentenceSpoken = true; // Prevent further weather announcements
    }
  }
}

// --- Adjusted checkHardcodedTurns ---
function checkHardcodedTurns(userCoords) {
  const now = Date.now();
  // Only allow direction if 6s after any message
  if (now - lastAnySpokenTime < DIRECTION_MIN_INTERVAL) return;
  // Only allow direction if 6s after last direction (for safety)
  if (now - lastDirectionSpokenTime < DIRECTION_MIN_INTERVAL) return;
  if (now < blockDirectionsUntil) return;

  const normalTurns = activeTurnPoints.slice(0, -2);
  const lastRechts = activeTurnPoints[activeTurnPoints.length - 2];
  const weerTerug = activeTurnPoints[activeTurnPoints.length - 1];

  function getTurnSentence(dir) {
    if (dir === "rechts") return "Laten we hier rechtsaf slaan.";
    if (dir === "links") return "Hier gaan we naar links.";
    if (dir === "rechtdoor") return "Hier blijven we rechtdoor gaan.";
    if (dir === "plein") return "Laten we hier rechtsaf het plein op gaan en langs de kerk lopen";
    return `Hier moet je naar ${dir}`;
  }

  // Announce normal turns first
  for (let i = 0; i < normalTurns.length; i++) {
    const turn = normalTurns[i];
    if (turn.announced) continue;
    const dist = turf.distance(
      turf.point([userCoords[1], userCoords[0]]),
      turf.point([turn.lng, turn.lat]),
      { units: 'meters' }
    );

    // Specifieke check: de laatste "rechtdoor" op (51.387083, 5.443449) mag pas na 5 directies
    if (
      turn.dir === "rechtdoor" &&
      Math.abs(turn.lat - 51.387083) < 0.00002 &&
      Math.abs(turn.lng - 5.443449) < 0.00002 &&
      directionCount < 5
    ) {
      continue; // Wacht tot er 5 directies zijn gegeven
    }

    // Prevent announcing a turn if a previous turn at the same coordinate is not yet announced
    let earlierUnannouncedAtSameSpot = false;
    for (let j = 0; j < i; j++) {
      const prevTurn = normalTurns[j];
      if (
        !prevTurn.announced &&
        Math.abs(prevTurn.lat - turn.lat) < 0.00001 &&
        Math.abs(prevTurn.lng - turn.lng) < 0.00001
      ) {
        earlierUnannouncedAtSameSpot = true;
        break;
      }
    }
    if (earlierUnannouncedAtSameSpot) continue;

    if (dist < 12) {
      speak(getTurnSentence(turn.dir), "direction");
      turn.announced = true;
      lastDirectionAnnounceTime = Date.now();
      directionCount++;
      // After 5 directions, trigger encouragement if not yet given, but wait 20s
      if (directionCount === 5 && !encouragementGiven) {
        setTimeout(() => {
          speak("Je bent goed bezig. Het is zo belangrijk om in beweging te blijven.", "reassure");
          encouragementGiven = true;
          blockDirectionsUntil = Date.now() + 5000; // Block directions for 5s
          lastObjectAnnounceTime = Date.now(); // Block objects for 5s
        }, 20000); // Wait 20s after 5th direction
      }
      blockDirectionsUntil = Date.now() + 5000; // Block directions for 5s
      lastObjectAnnounceTime = Date.now(); // Block objects for 5s
      return;
    }
  }

  // Only announce the last "rechts" if all previous are announced
  if (normalTurns.every(t => t.announced) && lastRechts && !lastRechts.announced) {
    const dist = turf.distance(
      turf.point([userCoords[1], userCoords[0]]),
      turf.point([lastRechts.lng, lastRechts.lat]),
      { units: 'meters' }
    );
    if (dist < 12) {
      speak(getTurnSentence(lastRechts.dir), "direction");
      lastRechts.announced = true;
      lastDirectionAnnounceTime = Date.now();
      directionCount++;
      if (directionCount === 4 && !encouragementGiven) {
        setTimeout(() => {
          speak("Je bent goed bezig. Het is zo belangrijk om in beweging te blijven.", "reassure");
          encouragementGiven = true;
          blockDirectionsUntil = Date.now() + 5000;
          lastObjectAnnounceTime = Date.now();
        }, 20000); // Wait 20s after 4th direction
      }
      blockDirectionsUntil = Date.now() + 5000;
      lastObjectAnnounceTime = Date.now();
      return;
    }
  }

  // Only announce "Weer terug" if all previous are announced
  if (
    normalTurns.every(t => t.announced) &&
    lastRechts && lastRechts.announced &&
    weerTerug && !weerTerug.announced
  ) {
    const dist = turf.distance(
      turf.point([userCoords[1], userCoords[0]]),
      turf.point([weerTerug.lng, weerTerug.lat]),
      { units: 'meters' }
    );
    if (dist < 8) {
      speak("En daar zijn we weer terug bij het klooster. Voor je zie je de voordeur. Wat fijn om zo samen op pad te zijn geweest.", "direction");
      weerTerug.announced = true;
      lastDirectionAnnounceTime = Date.now();
      showEndScreen();
      return;
    }
  }
}

// --- When speaking the reassurance message, use the type "reassure" ---
// Already done in the setTimeout above

    async function loadObjects() {
      const files = [
        'Objects/boom.geojson',
        'Objects/bank.geojson',
        'Objects/kunstobject.geojson',
        'Objects/speeltuin.geojson',
        'Objects/sportterrein.geojson',
        'Objects/afvalbak.geojson',
        'Objects/fietsenrek.geojson',
        'Objects/haag.geojson',
        'Objects/klinkers.geojson',
        'Objects/restaurant.geojson',
        'Objects/kerk.geojson' // <-- Add this line for churches
      ];
      const allObjects = [];
      for (const file of files) {
        try {
          const res = await fetch(file);
          const geo = await res.json();
          // For restaurant.geojson, set type to "restaurant" if not present
          if (file.includes('restaurant.geojson')) {
            geo.features.forEach(f => {
              if (!f.properties.type) f.properties.type = "restaurant";
            });
          }
          // For kerk.geojson, set type to "kerk" if not present
          if (file.includes('kerk.geojson')) {
            geo.features.forEach(f => {
              if (!f.properties.type) f.properties.type = "kerk";
            });
          }
          allObjects.push(...geo.features);
        } catch (err) {
          // Ignore missing files
        }
      }
      return allObjects;
    }

    async function loadRoute(type) {
      let file = '';
      if (type === 'kort') file = 'Routes/route_kort.geojson';
      if (type === 'middel') file = 'Routes/route_middel.geojson';
      if (type === 'lang') file = 'Routes/route_lang.geojson';
      const res = await fetch(file);
      const geo = await res.json();
      // Assume first feature is the route
      return geo.features[0].geometry.coordinates;
    }

    async function fetchWeather() {
      // Replace YOUR_API_KEY with your OpenWeatherMap API key
      const apiKey = '128e6da6a66e01537fb6ca168cf0f677';
      const url = `https://api.openweathermap.org/data/2.5/weather?lat=51.3865&lon=5.4439&units=metric&appid=${apiKey}&lang=nl`;
      try {
        const res = await fetch(url);
        if (!res.ok) return null;
        return await res.json();
      } catch {
        return null;
      }
    }

    function getWeatherSentence(weather) {
      if (!weather) return null;
      const temp = weather.main.temp;
      const main = weather.weather[0].main.toLowerCase();
      const desc = weather.weather[0].description.toLowerCase();
      const isRaining = main.includes("rain") || desc.includes("regen");
      const isSunny = main.includes("clear") || desc.includes("zon");
      const isCloudy = main.includes("cloud") || desc.includes("bewolkt") || desc.includes("wolken");

      if (isRaining) {
        return "Wat goed dat je met dit mindere weer een wandelingetje gaat maken zeg! Zo goed om even de benen te strekken.";
      }
      if (isSunny && temp > 22) {
        return "Pfoee, wat een lekker warm weertje vandaag he?";
      }
      if (isSunny && temp >= 10 && temp <= 22) {
        return "Wat een heerlijk zonnetje schijnt er vandaag he?";
      }
      if (temp < 10 && !isRaining) {
        if (isCloudy) {
          return "Lekker fris buiten, maar zo’n wandeling doet altijd goed!";
        }
        return "Fris weertje vandaag hè? Goed om toch even naar buiten te gaan!";
      }
      if (isCloudy && temp > 10) {
        return "Ook zonder zon is het fijn om even een frisse neus te halen, goed bezig!";
      }
      return null;
    }

    async function speakWeatherIfQuiet() {
      const now = Date.now();
      if (!weatherData) return;
      // Block weather message for 90s after opening message
      if (openingMessageTime && now - openingMessageTime < 90000) return;
      // Only if 30s after last direction, and 90s after last object/weather/reassure, and only once
      if (now - lastDirectionSpokenTime < AFTER_DIRECTION_BLOCK) return;
      if (now - lastObjectWeatherReassureTime < OBJECT_WEATHER_REASSURE_MIN) return;
      if (!weatherSentenceSpoken && now - lastSpokenTime > 10000 && now - lastWeatherAnnounceTime > 10000) {
        const zin = getWeatherSentence(weatherData);
        if (zin) {
          speak(zin, "weather");
          lastWeatherAnnounceTime = Date.now();
          blockDirectionsUntil = Date.now() + 3000; // Block directions for 3s
          lastObjectAnnounceTime = Date.now(); // Block objects for 10s
          weatherSentenceSpoken = true; // Prevent further weather announcements
        }
      }
    }

   async function speakWithElevenLabs(text) {
  const apiKey = 'sk_7babea5a8b5660df211f740b08f3dedba85808f13fd48b69';  // ❗️Verberg deze in productie
  const voiceId = 'knrPHWnBmmDHMoiMeP3l'; // Voorbeeldstem die NL ondersteunt (bijv. 'Rachel')
  
  const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${voiceId}`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'xi-api-key': apiKey
    },
    body: JSON.stringify({
      text: text,
      model_id: 'eleven_multilingual_v2', // ✅ Nodig voor goede Nederlandse uitspraak
      voice_settings: {
        stability: 0.5,
        similarity_boost: 0.75
      }
    })
  });

  if (!response.ok) {
    console.error('Error from ElevenLabs:', await response.text());
    return;
  }

  const audioBlob = await response.blob();
  const audioUrl = URL.createObjectURL(audioBlob);
  const audio = new Audio(audioUrl);
  audio.play();
}

    async function fetchRealWorldRoute(waypoints) {
      // If there are less than 3 points, just return as is
      if (waypoints.length < 3) return waypoints;

      // Keep first and last point as-is
      const first = waypoints[0];
      const last = waypoints[waypoints.length - 1];
      const middle = waypoints.slice(1, -1);

      // Snap only the middle points to the road
      const apiKey = '5b3ce3597851110001cf62487fcb39e0f04c4854b85088cd255aee42';
      const url = 'https://api.openrouteservice.org/v2/directions/foot-walking/geojson';
      const body = { coordinates: [first, ...middle, last] };
      const res = await fetch(url, {
        method: 'POST',
        headers: {
          'Authorization': apiKey,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(body)
      });
      const data = await res.json();

      // Replace the first and last snapped points with the original ones
      let snapped = data.features[0].geometry.coordinates;
      if (snapped.length >= 2) {
        snapped[0] = first;
        snapped[snapped.length - 1] = last;
      }
      return snapped;
    }

    function updateUserLocation(lat, lon) {
      userPosition = [lat, lon];
      if (currentMarker) map.removeLayer(currentMarker);
      const icon = L.divIcon({ className: 'user-dot' });
      currentMarker = L.marker([lat, lon], { icon }).addTo(map);
    }

    function checkNearbyObjects(userCoords, features) {
      const now = Date.now();
      // --- NIEUW: Wacht tot er minstens 2 directies zijn gegeven ---
      if (directionCount < 2) return;
      // Alleen toestaan als:
      // - 30s na laatste direction
      // - 90s na laatste object/weather/reassure
      if (now - lastDirectionSpokenTime < AFTER_DIRECTION_BLOCK) return;
      if (now - lastObjectWeatherReassureTime < OBJECT_WEATHER_REASSURE_MIN) return;

      for (const feature of features) {
        if (!feature.geometry || !Array.isArray(feature.geometry.coordinates)) continue;
        let objectCoords;
        if (feature.geometry.type === 'Point') {
          objectCoords = feature.geometry.coordinates;
        } else if (feature.geometry.type === 'Polygon') {
          const centroid = turf.centroid(feature.geometry).geometry.coordinates;
          objectCoords = centroid;
        } else continue;
        if (typeof objectCoords[0] !== 'number' || typeof objectCoords[1] !== 'number') continue;

        // Bepaal het type en de juiste afstandsgrens
        let type = feature.properties?.type || feature.properties?.["plus-type"] || "onbekend";
        if (typeof type !== "string") type = "onbekend";
        type = type.toLowerCase();
        const distanceThreshold = (type === "kerk") ? 45 : 15;

        const distance = turf.distance(
          turf.point([userCoords[1], userCoords[0]]),
          turf.point([objectCoords[0], objectCoords[1]]),
          { units: 'meters' }
        );
        if (distance < distanceThreshold && !feature.properties.announced) {
          feature.properties.announced = true;
          if (announcedTypes.has(type)) continue;
          announcedTypes.add(type);

          // Special handling for kerk: include the name if available
          if (type === "kerk") {
            const kerkNaam = feature.properties.name ? feature.properties.name : "de kerk";
            speak(`Hier zie je ${kerkNaam}, een bijzonder gebouw in het dorp.`, "object");
          } else {
            const zin = objectZinnen[type] || "Je komt langs een onbekend object.";
            speak(zin, "object");
          }
          lastObjectAnnounceTime = Date.now();
          blockDirectionsUntil = Date.now() + 3000;
          return;
        }
      }
    }

    function checkHardcodedTurns(userCoords) {
      const now = Date.now();
      // Only allow direction if 6s after any message
      if (now - lastAnySpokenTime < DIRECTION_MIN_INTERVAL) return;
      // Only allow direction if 6s after last direction (for safety)
      if (now - lastDirectionSpokenTime < DIRECTION_MIN_INTERVAL) return;
      if (now < blockDirectionsUntil) return;

      const normalTurns = activeTurnPoints.slice(0, -2);
      const lastRechts = activeTurnPoints[activeTurnPoints.length - 2];
      const weerTerug = activeTurnPoints[activeTurnPoints.length - 1];

      function getTurnSentence(dir) {
        if (dir === "rechts") return "Laten we hier rechtsaf slaan.";
        if (dir === "links") return "Hier gaan we naar links.";
        if (dir === "rechtdoor") return "Hier blijven we rechtdoor gaan.";
        if (dir === "plein") return "Laten we hier rechtsaf het plein op gaan en langs de kerk lopen";
        return `Hier moet je naar ${dir}`;
      }

      // Announce normal turns first
      for (let i = 0; i < normalTurns.length; i++) {
        const turn = normalTurns[i];
        if (turn.announced) continue;
        const dist = turf.distance(
          turf.point([userCoords[1], userCoords[0]]),
          turf.point([turn.lng, turn.lat]),
          { units: 'meters' }
        );

        // Specifieke check: de laatste "rechtdoor" op (51.387083, 5.443449) mag pas na 5 directies
        if (
          turn.dir === "rechtdoor" &&
          Math.abs(turn.lat - 51.387083) < 0.00002 &&
          Math.abs(turn.lng - 5.443449) < 0.00002 &&
          directionCount < 5
        ) {
          continue; // Wacht tot er 5 directies zijn gegeven
        }

        // Prevent announcing a turn if a previous turn at the same coordinate is not yet announced
        let earlierUnannouncedAtSameSpot = false;
        for (let j = 0; j < i; j++) {
          const prevTurn = normalTurns[j];
          if (
            !prevTurn.announced &&
            Math.abs(prevTurn.lat - turn.lat) < 0.00001 &&
            Math.abs(prevTurn.lng - turn.lng) < 0.00001
          ) {
            earlierUnannouncedAtSameSpot = true;
            break;
          }
        }
        if (earlierUnannouncedAtSameSpot) continue;

        if (dist < 12) {
          speak(getTurnSentence(turn.dir), "direction");
          turn.announced = true;
          lastDirectionAnnounceTime = Date.now();
          directionCount++;
          // After 5 directions, trigger encouragement if not yet given, but wait 20s
          if (directionCount === 5 && !encouragementGiven) {
            setTimeout(() => {
              speak("Je bent goed bezig. Het is zo belangrijk om in beweging te blijven.", "reassure");
              encouragementGiven = true;
              blockDirectionsUntil = Date.now() + 5000; // Block directions for 5s
              lastObjectAnnounceTime = Date.now(); // Block objects for 5s
            }, 20000); // Wait 20s after 5th direction
          }
          blockDirectionsUntil = Date.now() + 5000; // Block directions for 5s
          lastObjectAnnounceTime = Date.now(); // Block objects for 5s
          return;
        }
      }

      // Only announce the last "rechts" if all previous are announced
      if (normalTurns.every(t => t.announced) && lastRechts && !lastRechts.announced) {
        const dist = turf.distance(
          turf.point([userCoords[1], userCoords[0]]),
          turf.point([lastRechts.lng, lastRechts.lat]),
          { units: 'meters' }
        );
        if (dist < 12) {
          speak(getTurnSentence(lastRechts.dir), "direction");
          lastRechts.announced = true;
          lastDirectionAnnounceTime = Date.now();
          directionCount++;
          if (directionCount === 4 && !encouragementGiven) {
            setTimeout(() => {
              speak("Je bent goed bezig. Het is zo belangrijk om in beweging te blijven.", "reassure");
              encouragementGiven = true;
              blockDirectionsUntil = Date.now() + 5000;
              lastObjectAnnounceTime = Date.now();
            }, 20000); // Wait 20s after 4th direction
          }
          blockDirectionsUntil = Date.now() + 5000;
          lastObjectAnnounceTime = Date.now();
          return;
        }
      }

      // Only announce "Weer terug" if all previous are announced
      if (
        normalTurns.every(t => t.announced) &&
        lastRechts && lastRechts.announced &&
        weerTerug && !weerTerug.announced
      ) {
        const dist = turf.distance(
          turf.point([userCoords[1], userCoords[0]]),
          turf.point([weerTerug.lng, weerTerug.lat]),
          { units: 'meters' }
        );
        if (dist < 8) {
          speak("En daar zijn we weer terug bij het klooster. Voor je zie je de voordeur. Wat fijn om zo samen op pad te zijn geweest.", "direction");
          weerTerug.announced = true;
          lastDirectionAnnounceTime = Date.now();
          showEndScreen();
          return;
        }
      }
    }

    // --- Route Guidance ---
    function getNextRouteIndex(pos, coords, currentIdx) {
      // Find the closest next point on the route
      let minDist = Infinity, idx = currentIdx;
      for (let i = currentIdx; i < coords.length; i++) {
        const dist = turf.distance(
          turf.point([pos[1], pos[0]]),
          turf.point([coords[i][0], coords[i][1]]),
          { units: 'meters' }
        );
        if (dist < minDist) {
          minDist = dist;
          idx = i;
        }
      }
      return idx;
    }

    let lastTurnIdx = -1;
    function checkRouteGuidance(pos, coords) {
      // Find closest point on route
      const idx = getNextRouteIndex(pos, coords, currentRouteIndex);
      if (idx > currentRouteIndex) currentRouteIndex = idx;
      // Check if a turn is coming up
      if (idx > 0 && idx < coords.length - 1 && idx !== lastTurnIdx) {
        const prev = coords[idx - 1], curr = coords[idx], next = coords[idx + 1];
        const turn = getTurnInstruction(prev, curr, next);
        if (turn) {
          speak(`Hier moet je naar ${turn}`);
          lastTurnIdx = idx;
        }
      }
    }

    // --- Hardcoded turn points for each route type ---
    // Fill in the coordinates and directions for your routes!
    const turnPointsByRoute = {
      kort: [
        { lat: 51.387348, lng: 5.443318, dir: "rechts" },
        { lat: 51.387714, lng: 5.443246, dir: "links" },
        { lat: 51.387627, lng: 5.441539, dir: "links" },
        { lat: 51.387028, lng: 5.441920, dir: "rechtdoor" },
        { lat: 51.386585, lng: 5.443084, dir: "links" },
        { lat: 51.386609, lng: 5.443492, dir: "links" },
        { lat: 51.387121, lng: 5.443417, dir: "rechtdoor" },
        { lat: 51.387348, lng: 5.443318, dir: "rechts" },
        { lat: 51.387405, lng: 5.443736, dir: "Weer terug" },

      ],
      middel: [
        { lat: 51.387348, lng: 5.443318, dir: "links" },
        { lat: 51.387088, lng: 5.443431, dir: "links" },
          { lat: 51.387303, lng: 5.444765, dir: "rechtdoor" },
         { lat: 51.387494, lng: 5.445949, dir: "rechts" },
          { lat: 51.387212, lng: 5.446041, dir: "rechts" },
           { lat: 51.387142, lng: 5.445778, dir: "links" },
           { lat: 51.386524, lng: 5.446117, dir: "rechts" },
          { lat: 51.386390, lng: 5.445628, dir: "rechtdoor" },
           { lat: 51.386243, lng: 5.444643, dir: "rechtdoor" },
           { lat: 51.386168, lng: 5.444415, dir: "plein" },
           { lat: 51.386405, lng: 5.443573, dir: "rechts" },
            { lat: 51.387083, lng: 5.443449, dir: "rechtdoor" },
             { lat: 51.387348, lng: 5.443318, dir: "rechts" },
        { lat: 51.387405, lng: 5.443736, dir: "Weer terug" },
      ],
      lang: [
        { lat: 51.387348, lng: 5.443318, dir: "rechts" },
        { lat: 51.387714, lng: 5.443246, dir: "links" },
        { lat: 51.387627, lng: 5.441539, dir: "rechtdoor" },
          { lat: 51.387604, lng: 5.440893, dir: "rechtdoor" },
        { lat: 51.387821, lng: 5.439224, dir: "links" },
        { lat: 51.387288, lng: 5.439156, dir: "rechts" },
           { lat: 51.387023, lng: 5.437679, dir: "links" },
        { lat: 51.386938, lng: 5.437711, dir: "rechtdoor" },
        { lat: 51.386385, lng: 5.437822, dir: "rechtdoor" },
             { lat: 51.385760, lng: 5.438039, dir: "links" },
        { lat: 51.385849, lng: 5.438430, dir: "rechtdoor" },
        { lat: 51.386117, lng: 5.439493, dir: "rechtdoor" },
              { lat: 51.386412, lng: 5.441286, dir: "links" },
        { lat: 51.386877, lng: 5.441175, dir: "rechts" },
        { lat: 51.387028, lng: 5.441920, dir: "rechts" },
        { lat: 51.386585, lng: 5.443084, dir: "links" },
        { lat: 51.386609, lng: 5.443492, dir: "links" },
        { lat: 51.387121, lng: 5.443417, dir: "rechtdoor" },
        { lat: 51.387348, lng: 5.443318, dir: "rechts" },
        { lat: 51.387405, lng: 5.443736, dir: "Weer terug" },
      ]
    };

    let activeTurnPoints = [];

    function setActiveTurnPoints(routeType) {
      activeTurnPoints = (turnPointsByRoute[routeType] || []).map(tp => ({
        ...tp,
        announced: false
      }));
    }

    // --- Main Simulation ---
    async function startSimulation(routeType) {
      // Fetch weather at the start of the walk
      weatherData = await fetchWeather();

      // Init map
      map = L.map('map', { keyboard: false }).setView([51.3865, 5.4439], 17);
      L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

      // Load route and objects
      const waypoints = await loadRoute(routeType);
      routeCoords = await fetchRealWorldRoute(waypoints);

      geojsonData = await loadObjects();

      // Draw route
      if (routeLine) map.removeLayer(routeLine);
      routeLine = L.polyline(routeCoords.map(c => [c[1], c[0]]), {
        color: "#e1a83e", // yellow highlight
        weight: 6,
        opacity: 0.95
      }).addTo(map);
      map.fitBounds(routeLine.getBounds());

      // Place user at start
      userPosition = [routeCoords[0][1], routeCoords[0][0]];
      updateUserLocation(userPosition[0], userPosition[1]);
      currentRouteIndex = 0;
      lastTurnIdx = -1;
      announcedTypes.clear();
      geojsonData.forEach(f => { if (f.properties) f.properties.announced = false; });

      setActiveTurnPoints(routeType);

      // Start GPS tracking in plaats van toetsenbordnavigatie
      startGpsTracking();

      // Initial check
      lastSpokenTime = Date.now();
      lastWeatherAnnounceTime = 0;
      checkNearbyObjects(userPosition, geojsonData);

      // Start weather check interval
      if (window.weatherInterval) clearInterval(window.weatherInterval);
      window.weatherInterval = setInterval(speakWeatherIfQuiet, 1000);

      // --- Remove duplicate opening sentence here ---
      // (No speak or setTimeout for "Hallo, ik ben Gerard..." here)
    }

    function startGpsTracking() {
  if (navigator.geolocation) {
    navigator.geolocation.watchPosition(
      pos => {
        const lat = pos.coords.latitude;
        const lon = pos.coords.longitude;
        updateUserLocation(lat, lon);
        map.panTo([lat, lon]);
        checkNearbyObjects([lat, lon], geojsonData);
        checkHardcodedTurns([lat, lon]);
        checkOffRoute([lat, lon], routeCoords);
      },
      err => {
        console.error("GPS error:", err);
      },
      { enableHighAccuracy: true, maximumAge: 1000, timeout: 10000 }
    );
  } else {
    alert("GPS niet ondersteund op dit apparaat.");
  }
}

    // End screen HTML
    const endScreenHtml = `
      <div id="endScreen" class="center-screen" style="display:none;">
        <div class="welcome-title" style="margin-bottom: 0.7em;">Wat een fijne wandeling, tot de volgende!</div>
        <button class="start-btn" onclick="restartWalk()" style="margin-top: 0;">Nog een rondje</button>
      </div>
    `;
    document.body.insertAdjacentHTML('beforeend', endScreenHtml);

    function showEndScreen() {
      document.getElementById('map').style.display = 'none';
      document.getElementById('endScreen').style.display = 'flex';
      if (window.weatherInterval) clearInterval(window.weatherInterval);
    }

    function restartWalk() {
      document.getElementById('endScreen').style.display = 'none';
      document.getElementById('routeScreen').style.display = 'flex';

      lastObjectAnnounceTime = 0;
      lastDirectionAnnounceTime = 0;
      blockDirectionsUntil = 0;
      lastTurnIdx = -1;
      currentRouteIndex = 0;
      lastSpokenTime = Date.now();
      lastWeatherAnnounceTime = 0;
      weatherSentenceSpoken = false; // Reset here
      directionCount = 0;
      encouragementGiven = false;

      announcedTypes.clear();
      if (geojsonData && geojsonData.length > 0) {
        geojsonData.forEach(f => { if (f.properties) f.properties.announced = false; });
      }
      if (typeof activeTurnPoints !== "undefined" && activeTurnPoints.length > 0) {
        activeTurnPoints.forEach(tp => tp.announced = false);
      }

      if (currentMarker) {
        map.removeLayer(currentMarker);
        currentMarker = null;
      }
      if (routeLine) {
        map.removeLayer(routeLine);
        routeLine = null;
      }

      userPosition = [51.3865, 5.4439];
      document.removeEventListener('keydown', onKeyMove);

      if (map) {
        map.remove();
        map = null;
      }
    }

    function getDynamicTurnInstruction(userCoords, previousCoords, routeCoords) {
  // Find closest route index
  let minDist = Infinity, idx = 0;
  for (let i = 0; i < routeCoords.length; i++) {
    const dist = turf.distance(
      turf.point([userCoords[1], userCoords[0]]),
      turf.point([routeCoords[i][0], routeCoords[i][1]]),
      { units: 'meters' }
    );
    if (dist < minDist) {
      minDist = dist;
      idx = i;
    }
  }
  if (idx < routeCoords.length - 1 && previousCoords) {
    // User's heading
    const userHeading = turf.bearing(
      turf.point([previousCoords[1], previousCoords[0]]),
      turf.point([userCoords[1], userCoords[0]])
    );
    // Route's heading
    const routeHeading = turf.bearing(
      turf.point([userCoords[1], userCoords[0]]),
      turf.point([routeCoords[idx + 1][0], routeCoords[idx + 1][1]])
    );
    // Difference
    let diff = routeHeading - userHeading;
    // Normalize to [-180, 180]
    while (diff > 180) diff -= 360;
    while (diff < -180) diff += 360;
    if (diff > 45) return "rechts";
    if (diff < -45) return "links";
    return "rechtdoor";
  }
  return null;
}

function checkOffRoute(userCoords, routeCoords) {
  if (!routeCoords || routeCoords.length === 0) return;

  // Create a LineString from the route coordinates
  const line = turf.lineString(routeCoords);

  // User's current position as a Point
  const userPoint = turf.point([userCoords[1], userCoords[0]]);

  // Calculate the shortest distance from the user to the route line (in meters)
  const minDist = turf.pointToLineDistance(userPoint, line, { units: 'meters' });

  // First warning at >20m
  if (minDist > 20 && minDist <= 40 && !offRouteWarned) {
    speak("Oh, we moeten even omkeren om op de juiste route te komen. Dan zitten we weer goed.");
    offRouteWarned = true;
    blockDirectionsUntil = Date.now() + 4000;
    lastObjectAnnounceTime = Date.now();
  }
  // Second warning at >40m
  if (minDist > 40 && offRouteWarned !== "second") {
    speak("Laten we omkeren en weer de juiste kant opgaan.");
    offRouteWarned = "second";
    blockDirectionsUntil = Date.now() + 4000;
    lastObjectAnnounceTime = Date.now();
  }
  // Reset warning if user is back on route
  if (minDist <= 10 && offRouteWarned) {
    offRouteWarned = false;
    // Announce dynamic direction to next point
    const dir = getDynamicTurnInstruction(userCoords, previousUserPosition, routeCoords);
    if (dir) {
      if (dir === "rechts") speak("We zijn weer op de route. Hier gaan we naar rechts.");
      else if (dir === "links") speak("We zijn weer op de route. Hier gaan we naar links.");
      else speak("We zijn weer op de route. Hier gaan we rechtdoor.");
    } else {
      speak("We zijn weer op de route.");
    }
  }
}
  </script>
</body>
</html>






